{
  "author": {
    "name": "Jérémy Lal",
    "email": "kapouer@melix.org"
  },
  "name": "express-notemplate",
  "description": "Express view engine, merges data into DOM using plain JS",
  "keywords": [
    "template",
    "DOM",
    "asynchronous",
    "cache"
  ],
  "version": "0.1.18",
  "repository": {
    "type": "git",
    "url": "git://github.com/kapouer/express-notemplate.git"
  },
  "license": "MIT",
  "dependencies": {
    "express": "3.x",
    "jsdom": "0.7.x",
    "jquery-browser": "2.0.x",
    "step": "0.0.x"
  },
  "main": "./notemplate.js",
  "readme": "express-notemplate\n==================\n\nLet the template be plain HTML code, and use javascript to merge data into it.\n\nWhy ?\n-----\n\nThe view is totally separated from the model.\nThe glue code that merges data into the view is easy to maintain, and can be run by the server or the clients.\nThere is no artificial syntax, no unnecessary abstraction.\nJust familiar DOM and javascript.\n\nIn particular, this allows one to merge new data on the clients using a messenging system using the exact same code\nas what is needed on the server to output html.\n\nThe only extra is a jQuery $ object provided by default on server.\n(if the javascript code is not used on clients, jQuery is not needed on clients).\n\n\nExpress 3 Setup\n---------------\n\n\tvar notemplate = require('express-notemplate');\n\tapp.set('statics', process.cwd() + '/public');\n\tapp.set('views', process.cwd() + '/views');\n\tapp.engine('html', notemplate.__express);\n\tapp.set('view engine', 'html');\n\tapp.use(express.static(app.get('statics')));\n\tapp.use(notemplate.middleware); // initialize document.location\n\nUsage\n-----\n\nIt is meant to be used as any other express view rendering :\n\n\tres.locals.mydata = mydata;\n\tres.render('index');\n\nThen express-notemplate will load the html file into a DOM, add window.$ to it, and process script tags :\n\n\t<script type=\"text/javascript\">\n\t\t// some client code here, won't be run on server\n\t</script>\n\t<script type=\"text/javascript\" notemplate=\"both\" src=\"javascripts/moment.js\"></script>\n\t<script type=\"text/javascript\" notemplate=\"server\">\n\t\t$(document).on('data', function(e, data) {\n\t\t\t$('head > title').text(data.mydata.title + moment());\n\t\t});\n\t</script>\n\t<script type=\"text/javascript\" notemplate=\"both\">\n\t\t$(document).on('data', function(e, data) {\n\t\t\t$('body').html(data.mydata.body);\n\t\t});\n\t\t$(document).ready(function() {\n\t\t\tif (window.navigator.server) return; // is true when run on server inside notemplate. Will change when jsdom supports it.\n\t\t\t// do client ui stuff here that won't be useful on server\n\t\t});\n\t</script>\n\n\nIn this example :\n\n* moment.js is loaded and the script tag is kept in the html output,\n* the first handler is run on server but won't be available on client\n* the second handler is run and it will be possible to trigger it on client too.\n\nscript tags can have attribute notemplate = server | client | both :\n\n* (default) client : script are not run\n* server : scripts are run and tag is removed\n* both : scripts are run\n\nThe \"notemplate\" attribute is removed from html output.\n\nIE-style conditional comments are replaced by the tag they contain (provided there is only one tag in it),\nbefore document.ready event and are restored before output event. It allows all notemplate middleware\nto process the nodes hidden within those comments the same way as other nodes.\n\n\nMiddleware\n----------\n\nOnly page-bound scripts can listen to these events:\n\n* $(document).ready(function() {})\n  the usual document.ready event.  \n  Modifying DOM before that event is unsupported.\n  Use notemplate.ready to do just that.\n* $(document).on('data', function(e, obj) {})\n  obj can be the options object given by express to template engines render method.  \n  It can also be a simple object received through other channels (say a message\n  from a websocket connection).\n  It is advised to check for existence of obj.mydatakey before trying to use it.  \n  Listener arguments : e, locals\n\n\nOnly nodejs-bound scripts can listen to these events (emitted by notemplate):\n\n* notemplate.on('ready', function(view, opts) {})\n\tDOM is loaded in view.window and will be copied over each new page instance.\n\tOnly jquery is available.\n* notemplate.on('data', function(view, opts) {})\n  called just before document.data handlers.\n* notemplate.on('render', function(view, opts) {})\n\tcalled just after document.data handlers.  \n\tview.instance.toString() will serialize dom, respecting fragment options.  \n\tSetting view.instance.output will prevent next step from calling toString.\n* notemplate.on('output', function(instance, opts) {})\n\tcalled just after instance.output has been set.  \n\tinstance.output can be anything, since it can be customized in a render event\n\tlistener before. See usage below.\n\n\nUsage :\n\n\tview.window\n\tview.window.$\n\tview.window.document\n\tview.window.console\n\n\topts.settings.env\n\topts.locals.mydata\n\topts.mydata\n\topts.use(...)\n\t\t\n\n\tvar notemplate = require('express-notemplate');\n\t../..\n\tnotemplate.on('output', function(ref) {\n\t\tref.output = ref.output.replace('é', '&eacute;');\n\t});\n\nA typical use of middleware is in notemplate-minify.\n\nA typical use of render event middleware is in notemplate-archive.\n\n\nQuick jsdom window with jquery\n------------------------------\n\nIf you need quick access to an empty DOM with jquery,\n\n  require('notemplate').window(htmlstr, href)\n\nis what you need.\n\n\nTips\n----\n\n* console.log works in the jsdom context.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/kapouer/express-notemplate/issues"
  },
  "_id": "express-notemplate@0.1.18",
  "dist": {
    "shasum": "9019ec6a81c9a2580dbe8f81e47d998b85e76c97"
  },
  "_from": "express-notemplate@",
  "_resolved": "https://registry.npmjs.org/express-notemplate/-/express-notemplate-0.1.18.tgz"
}
